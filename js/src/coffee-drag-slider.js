// Generated by CoffeeScript 1.7.1
(function() {
  var $, Slider,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.sliders = {};

  $ = window.jQuery;

  Slider = (function() {
    function Slider(sliderId, config) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.sliderId = sliderId;
      if (config == null) {
        config = {};
      }
      this.dragg = __bind(this.dragg, this);
      this.settings = {
        viewportMaxWidth: (_ref = config.viewportMaxWidth) != null ? _ref : 1000,
        viewportMaxHeight: (_ref1 = config.viewportMaxHeight) != null ? _ref1 : 500,
        cycle: (_ref2 = config.cycle) != null ? _ref2 : true,
        navigator: (_ref3 = config.navigator) != null ? _ref3 : true,
        navigatorEvents: (_ref4 = config.navigatorEvents) != null ? _ref4 : false,
        autoHideBtns: (_ref5 = config.autoHideBtns) != null ? _ref5 : true,
        duration: (_ref6 = config.duration) != null ? _ref6 : 1,
        emmitEvents: (_ref7 = config.emmitEvents) != null ? _ref7 : false,
        draggable: (_ref8 = config.draggable) != null ? _ref8 : true
      };
      this.$sliderViewport = $('#' + sliderId);
      this.$slider = $(this.$sliderViewport.children('.slider'));
      this.$sliderItems = $(this.$slider.children('li'));
      this.$sliderPrevBtn = $(this.$sliderViewport.children('.prevBtn'));
      this.$sliderNextBtn = $(this.$sliderViewport.children('.nextBtn'));
      this.$sliderNavBtns = $(this.$sliderViewport.children('.navigator').children());
      if (this.settings.preventLinksOnDrag) {
        this.$sliderLinks = this.$sliderItems.children().children();
      }
      this.setSlider();
      this.index = 0;
      this.slideToPos = 0;
      this.draggedEl = null;
      this.hasLimitClass = false;
      this.$sliderPrevBtn.click((function(_this) {
        return function(e) {
          e.stopPropagation();
          return _this.slideTo('prev');
        };
      })(this));
      this.$sliderNextBtn.click((function(_this) {
        return function(e) {
          e.stopPropagation();
          return _this.slideTo('next');
        };
      })(this));
      this.$sliderNavBtns.mousedown((function(_this) {
        return function(e) {
          var index;
          e.stopPropagation();
          index = $(e.currentTarget).index();
          return _this.slideTo(index);
        };
      })(this));
      if (this.settings.draggable) {
        this.$sliderViewport.on('mousedown', (function(_this) {
          return function(e) {
            e.stopPropagation();
            e.preventDefault();
            _this.draggedEl = e.currentTarget;
            _this.dragStart(e.pageX);
            return null;
          };
        })(this));
        this.$sliderViewport.on('touchstart', (function(_this) {
          return function(e) {
            var x;
            e = e.originalEvent;
            x = e.touches[0].pageX;
            _this.draggedEl = e.currentTarget;
            _this.dragStart(x, 'touchmove');
            return null;
          };
        })(this));
        $(document).on('mouseup', (function(_this) {
          return function(e) {
            e.stopPropagation();
            e.preventDefault();
            return _this.dragEnd(e.pageX);
          };
        })(this));
        this.$sliderViewport.on('touchend', (function(_this) {
          return function(e) {
            var x;
            x = e.originalEvent.touches[0].pageX;
            return _this.dragEnd(x);
          };
        })(this));
      }
      $(window).resize((function(_this) {
        return function() {
          return _this.setSlider();
        };
      })(this));
    }


    /*
    Not Working yet :S
    if @settings.preventLinksOnDrag
    
      @$sliderLinks.click (e)=>
        e.stopImmediatePropagation()
        e.preventDefault()
        if @draggedEl
          alert 'yep it was dragged'
          @draggedEl = null
          console.log '@draggedEl is ' + @draggedEl
        else
          alert 'nopes'
     */

    Slider.prototype.addNavigator = function() {
      var i, navigatorHtml, _i, _ref;
      navigatorHtml = '<ul class="navigator">';
      navigatorHtml += '<li class="navBullet selectedBullet"></li>';
      for (i = _i = 1, _ref = this.elementsQ; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        navigatorHtml += '<li class="navBullet"></li>';
      }
      navigatorHtml += '</ul>';
      this.$sliderViewport.append(navigatorHtml);
      if (this.settings.navigatorInParent) {
        return this.$sliderNavBtns = $(this.$sliderViewport.parent().find('.navigator a'));
      } else {
        return this.$sliderNavBtns = $(this.$sliderViewport.children('.navigator').children());
      }
    };

    Slider.prototype.setSlider = function() {
      var sliderItemWidth;
      this.viewPortWidth = this.$sliderViewport.width();
      this.elementsQ = this.$sliderItems.length;
      this.sliderWidth = this.elementsQ * 100;
      sliderItemWidth = 100 / this.elementsQ;
      this.rightLimit = (this.viewPortWidth * this.elementsQ) - this.viewPortWidth;
      this.$sliderItems.css('width', "" + sliderItemWidth + "%");
      this.$slider.css({
        'width': "" + this.sliderWidth + "%",
        'transition-duration': "" + this.settings.duration + "s"
      });
      return this.addNavigator();
    };

    Slider.prototype.dragStart = function(startX, inputEvent) {
      var $el, dragPos, slideToPos;
      if (inputEvent == null) {
        inputEvent = 'mousemove';
      }
      $el = $(this.draggedEl);
      this.dragStartX = startX;
      slideToPos = this.$slider.position().left;
      dragPos = (slideToPos / this.viewPortWidth) * 100;
      this.$slider.css({
        'left': "" + dragPos + "%",
        'transition-duration': '0s'
      });
      return $el.on(inputEvent, (function(_this) {
        return function(ev) {
          var x;
          ev = ev.originalEvent;
          x = inputEvent === 'mousemove' ? ev.pageX : ev.touches[0].pageX;
          return _this.dragg(startX, x, slideToPos);
        };
      })(this));
    };

    Slider.prototype.dragg = function(startX, currentX, slideToPos) {
      var dragPos, offsetX;
      offsetX = startX - currentX;
      slideToPos -= offsetX;
      if (slideToPos >= 0) {
        slideToPos = 0;
        this.isOutBounds = true;
        this.dragStartX = currentX;
        if (!this.hasLimitClass) {
          this.$sliderViewport.addClass('onLeftLimit');
          this.hasLimitClass = true;
        }
      } else if (slideToPos <= -this.rightLimit) {
        slideToPos = -this.rightLimit;
        this.isOutBounds = true;
        this.dragStartX = currentX;
        if (!this.hasLimitClass) {
          this.$sliderViewport.addClass('onRightLimit');
          this.hasLimitClass = true;
        }
      }
      dragPos = (slideToPos / this.viewPortWidth) * 100;
      this.$slider.css('left', dragPos + '%');
      this.isOutBounds = false;

      /*
      We should use a better way to move the elements around, using forced gpu calcs
      @$slider.css({
        '-webkit-transform': "translate3d(#{slideToPos}%, 0px, 0px) perspective(2000px)"
      })
       */
      return null;
    };

    Slider.prototype.dragEnd = function(currentX) {
      var minToAction, offsetPercentage, offsetX, tempIndex;
      if (this.draggedEl || this.clicked) {
        console.log('drag end event fired for ' + this.sliderId);
        console.log(this.draggedEl);
        if (this.hasLimitClass) {
          this.$sliderViewport.removeClass('onLeftLimit onRightLimit');
          this.hasLimitClass = false;
        }
        offsetX = this.dragStartX - currentX;
        offsetPercentage = Math.abs(offsetX / this.viewPortWidth);
        minToAction = 0.1;
        if (offsetPercentage < minToAction) {
          offsetPercentage = 0;
        }
        if (offsetX > 0 && !this.isOutBounds) {
          console.log("Dragued-> right");
          tempIndex = this.index + Math.ceil(offsetPercentage);
        } else if (offsetX < 0 && !this.isOutBounds) {
          console.log("Dragued-> left");
          tempIndex = this.index - Math.ceil(offsetPercentage);
        } else {
          console.log("Didn't move, or at least not much");
          tempIndex = this.index;
        }
        console.log("tempIndex:" + tempIndex);
        this.slideTo(tempIndex);
        $(this.draggedEl).off('mousemove');
        this.draggedEl = null;
        console.log(this.draggedEl);
        return false;
      }
    };


    /*
     * Moves the slider to the prev, next, or an specific position based on the command argument
     * @param {string}|{integer} command
     * @return {void}
     */

    Slider.prototype.slideTo = function(command) {
      var err, lastIndx, slideToPos;
      this.clicked = null;
      console.log('slideTo Called with argument:' + command);
      switch (command) {
        case 'next':
          this.index++;
          break;
        case 'prev':
          this.index--;
          break;
        case 'first':
          this.index = 0;
          break;
        case 'last':
          this.index = this.elementsQ - 1;
          break;
        default:
          if (isFinite(command)) {
            this.index = command;
          } else {
            err = 'Please provide a valid command for the slider [prev,next or a valid index]';
            console.error(err);
            return false;
          }
      }
      lastIndx = this.elementsQ - 1;
      if (this.index > lastIndx) {
        if (this.settings.cycle) {
          this.index = 0;
        } else {
          this.index = lastIndx;
          return false;
        }
      } else if (this.index < 0) {
        if (this.settings.cycle) {
          this.index = lastIndx;
        } else {
          this.index = 0;
          return false;
        }
      }
      console.log('index:' + this.index);
      slideToPos = -1 * (this.index * 100);
      if (this.settings.navigator) {
        this.$sliderNavBtns.removeClass('selectedBullet');
        $(this.$sliderNavBtns[this.index]).addClass('selectedBullet');
      }
      this.$slider.css({
        'left': "" + slideToPos + "%",
        'transition-duration': "" + this.settings.duration + "s"
      });
      if (this.settings.emmitEvents) {
        return $.event.trigger('onSlide', [this.index, this.sliderId]);
      }
    };

    return Slider;

  })();

  $(function() {
    return sliders.main = new Slider('mainSlider');
  });

}).call(this);

//# sourceMappingURL=coffee-drag-slider.map
